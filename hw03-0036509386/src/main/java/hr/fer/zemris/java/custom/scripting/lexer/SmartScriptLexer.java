package hr.fer.zemris.java.custom.scripting.lexer;

import hr.fer.zemris.java.custom.scripting.parser.SmartScriptParserException;

/**
 * A lexer used by {@code SmartScriptParser} to pass tokens.
 *
 * @author Mateo Imbri≈°ak
 */

public class SmartScriptLexer {

    /**
     * Used for storing input.
     */
    private char[] data;

    /**
     * Keeps track of the current index.
     */
    private int currentIndex = 0;

    /**
     * Current {@code SmartScriptToken} in the lexer.
     */
    private SmartScriptToken token;

    /**
     * Keeps track of the current state of
     * the {@code SmartScriptLexer}.
     */
    private SmartScriptLexerState state = SmartScriptLexerState.TEXT;

    /**
     * Length of the tags used by the {@code SmartScriptLexer}.
     */
    private static final int TAG_LENGTH = 2;

    /**
     * Default constructor that passes the given {@code String}
     * as input.
     *
     * @param input {@code String} to be used as input.
     *
     * @throws NullPointerException if input is null.
     */
    public SmartScriptLexer(String input) {
        if (input == null) {
            throw new NullPointerException("Input cannot be null.");
        }

        data = input.toCharArray();
    }

    /**
     * Finds the next {@code SmartScriptToken} based on the
     * {@code SmartScriptLexer}'s current state.
     *
     * @return next {@code SmartScriptToken} generated by
     * this {@code SmartScriptLexer}.
     *
     * @throws SmartScriptLexerException if the {@code SmartScriptLexer}
     * is not in a defined state.
     */
    public SmartScriptToken nextToken() {
        if (endOfLexer()) {
            return token;
        } else {
            if (data[currentIndex] == '{' && state.equals(SmartScriptLexerState.TEXT)) { // switch state if necessary
                if (currentIndex + 1 < data.length && data[currentIndex +1] == '$') {
                    state = SmartScriptLexerState.TAG;
                    currentIndex += TAG_LENGTH;
                    try {
                        return lookForTag();
                    } catch (IndexOutOfBoundsException exc) {
                        throw new SmartScriptLexerException("Empty tag found.");
                    }
                }
            } else {
                if (data[currentIndex] == '$' && state.equals(SmartScriptLexerState.TAG)) {
                    state = SmartScriptLexerState.TEXT;
                    currentIndex += TAG_LENGTH;

                    token = new SmartScriptToken(SmartScriptTokenType.EOT, null);

                    return token;
                }
            }
        }

        switch (state) {
            case TEXT:
                token = new SmartScriptToken(SmartScriptTokenType.TEXT, nextTextToken());
                break;
            case TAG:
                nextTagToken();
                break;
            default:
                throw new SmartScriptLexerException("Lexer is in illegal state.");
        }

        return token;
    }

    /**
     * Finds the {@code TAG} when first entering tag area.
     *
     * @return the {@code SmartScriptToken} containing the {@code TAG}.
     */
    private SmartScriptToken lookForTag() {
        char current = data[currentIndex];

        while (current == ' ' || current == '\n' || current == '\t' || current == '\r') {
            currentIndex++;
            current = data[currentIndex];
        }

        if (current == '=') {
            token = new SmartScriptToken(SmartScriptTokenType.TAG, "=");
            currentIndex++;
            return token;
        }
        StringBuilder ret = new StringBuilder();

        while (current != ' ' && current != '\n' && current != '\t' && current != '\r' && current != '$') {
            ret.append(current);
            currentIndex++;
            current = data[currentIndex];
        }

        token = new SmartScriptToken(SmartScriptTokenType.TAG, ret.toString());
        return token;
    }

    /**
     * Finds the next {@code SmartScriptToken} if the current
     * state is {@code TAG}.
     *
     * @throws SmartScriptLexerException if the input is in
     * unsupported format.
     */
    private void nextTagToken() {
        // skip empty elements
        char current = data[currentIndex];
        if (current == ' ' || current == '\t' || current == '\r' || current == '\n') {
            currentIndex++;
            nextToken();
            return;
        }

        if (Character.isLetter(current)) {
            token = new SmartScriptToken(SmartScriptTokenType.VARIABLE, variableProtocol());
        } else if (current == '\"') {
            token = new SmartScriptToken(SmartScriptTokenType.STRING, stringProtocol());
        } else if (current == '@') {
            token = new SmartScriptToken(SmartScriptTokenType.FUNCTION, functionProtocol());
        } else if (Character.isDigit(current)) {
            token = numericProtocol();
        } else if (current == '+' || current == '*' || current == '/' || current == '^') {
            token = new SmartScriptToken(SmartScriptTokenType.OPERATOR, Character.toString(current));
            currentIndex++;
        } else if (current == '-') {
            if (currentIndex + 1 < data.length && Character.isDigit(data[currentIndex + 1])) {
                token = numericProtocol();
            } else {
                token = new SmartScriptToken(SmartScriptTokenType.OPERATOR, Character.toString(current));
                currentIndex++;
            }
        } else {
            throw new SmartScriptLexerException("Invalid input.");
        }
    }

    /**
     * Finds the value of next {@code SmartScriptToken}
     * if it is a {@code Double} or an {@code Integer}.
     *
     * @return new {@code SmartScriptToken} to be used as a current token.
     *
     * @throws SmartScriptLexerException if the number format is invalid.
     */
    private SmartScriptToken numericProtocol() {
        boolean isDouble = false;
        StringBuilder toParse = new StringBuilder();

        toParse.append(data[currentIndex]);

        currentIndex++;

        while (currentIndex < data.length && (Character.isDigit(data[currentIndex]) || data[currentIndex] == '.')) {
            if (data[currentIndex] == '.' && currentIndex + 1 < data.length) {
                if (!isDouble && Character.isDigit(data[currentIndex + 1])) {
                    isDouble = true;
                    toParse.append(data[currentIndex]);
                    currentIndex++;
                } else {
                    break;
                }
            }

            toParse.append(data[currentIndex]);
            currentIndex++;
        }

        try {
            if (isDouble) {
                return new SmartScriptToken(SmartScriptTokenType.DOUBLE, Double.parseDouble(toParse.toString()));
            }

            return new SmartScriptToken(SmartScriptTokenType.INTEGER, Integer.parseInt(toParse.toString()));
        } catch (NumberFormatException exc) {
            throw new SmartScriptParserException("Invalid number format.");
        }
    }

    /**
     * Finds the value of next {@code SmartScriptToken}
     * if it is a {@code String}.
     *
     * @return value of the next {@code SmartScriptToken}.
     *
     * @throws SmartScriptLexerException if the function
     * name is invalid.
     */
    private String functionProtocol() {
        StringBuilder ret = new StringBuilder();
        currentIndex++;

        if (Character.isLetter(data[currentIndex])) {
            ret.append(variableProtocol());
        } else {
            throw new SmartScriptLexerException("Function name is invalid.");
        }

        return ret.toString();
    }

    /**
     * Finds the name of a variable in the code.
     *
     * @return a {@code String} representing the name of the variable.
     */
    private String variableProtocol() {
        StringBuilder ret = new StringBuilder();
        ret.append(data[currentIndex]);

        currentIndex++;
        char current = data[currentIndex];


        while (current != ' ' && current != '\t' && current != '\r' && current != '\n') {
            if (Character.isLetterOrDigit(current) || current == '_') {
                ret.append(current);
                currentIndex++;

                current = data[currentIndex];
            } else {
                break;
            }
        }

        return ret.toString();
    }

    /**
     * Finds the value of next {@code SmartScriptToken}
     * if it is a {@code String}.
     *
     * @return value of the next {@code SmartScriptToken}.
     *
     * @throws SmartScriptLexerException if escape sequence
     * is invalid.
     */
    private String stringProtocol() {
        currentIndex++;
        StringBuilder ret = new StringBuilder();

        while (currentIndex < data.length && data[currentIndex] != '\"') {
            if (data[currentIndex] == '\\' && currentIndex + 1 < data.length) {
                currentIndex++;

                switch (data[currentIndex]) {
                    case 'r':
                        ret.append('\r');
                        currentIndex++;
                        break;
                    case 'n':
                        ret.append('\n');
                        currentIndex++;
                        break;
                    case 't':
                        ret.append('\t');
                        currentIndex++;
                        break;
                    case '\\':
                    case '\"':
                        ret.append(data[currentIndex]);
                        currentIndex++;
                        break;
                    default:
                        throw new SmartScriptLexerException("Illegal escape attempt.");
                }
            } else {
                ret.append(data[currentIndex]);
                currentIndex++;
            }
        }

        currentIndex++;

        return ret.toString();
    }

    /**
     * Finds the next {@code SmartScriptToken} if the
     * {@code SmartScriptLexer} is in {@code TEXT} state.
     *
     * @return a {@code String} to be used as value of
     * the next {@code SmartScriptToken}.
     *
     * @throws SmartScriptLexerException if an illegal
     * escape was attempted.
     */
    private String nextTextToken() {
        StringBuilder ret = new StringBuilder();

        while (currentIndex < data.length) {
            if (data[currentIndex] == '{' && currentIndex + 1 < data.length) {
                if (data[currentIndex + 1] == '$') {
                    return ret.toString();
                }
            } else if (data[currentIndex] == '\\') {
                if (currentIndex + 1 < data.length) {
                    currentIndex++;
                    char current = data[currentIndex];

                    switch (current) {
                        case '\\':
                        case '{':
                            ret.append(current);
                            currentIndex++;
                            break;
                        default:
                            throw new SmartScriptLexerException("Illegal escape attempt");
                    }
                }
            }
            ret.append(data[currentIndex]);
            currentIndex++;
        }

        return ret.toString();
    }

    /**
     * Returns the {@code SmartScriptToken} currently
     * in the lexer.
     *
     * @return current {@code SmartScriptToken}.
     */
    public SmartScriptToken getToken() {
        return token;
    }

    /**
     * Used internally to check if the end of file has been reached and
     * {@link #nextToken()} has been called again.
     *
     * @return {@code true} if the end of file has been reached,
     * otherwise {@code false}.
     *
     * @throws SmartScriptLexerException if {@link #nextToken()} has been called
     * after the end of file has been reached or the tag has never been closed.
     */
    private boolean endOfLexer() {
        if (currentIndex > data.length) {
            throw new SmartScriptLexerException("This lexer has given it's last token.");
        }

        if (currentIndex == data.length) {
            if (state != SmartScriptLexerState.TEXT) {
                throw new SmartScriptLexerException("EOF has been reached but tag was never closed.");
            }

            token = new SmartScriptToken(SmartScriptTokenType.EOF, null);
            currentIndex++;
            return true;
        }

        return false;
    }
}
