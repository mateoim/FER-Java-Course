package hr.fer.zemris.java.hw03.prob1;

/**
 * A simple lexer that processes a {@code String} and
 * returns it as {@code Token}s based on data type.
 *
 * @author Mateo InbriÅ¡ak
 */

public class Lexer {

    /**
     * Used for storing input.
     */
    private char[] data;

    /**
     * Represents current {@code Token}.
     */
    private Token token;

    /**
     * Index of first unprocessed character.
     */
    private int currentIndex;

    /**
     * Represents the current state of this {@code Lexer}.
     */
    private LexerState state = LexerState.BASIC;

    /**
     * Default constructor that sets the given {@code String} as
     * the {@code Lexer}'s input.
     *
     * @param text a {@code String} that is used as input.
     */
    public Lexer(String text) {
        if (text == null) {
            throw new NullPointerException("Input must not be null.");
        }

        data = text.toCharArray();
        currentIndex = 0;
    }

    /**
     * Finds the next {@code Token} based on the {@code Lexer}'s current
     * state.
     *
     * @return next {@code Token} generated by this {@code Lexer}.
     */
    public Token nextToken() {
        switch (state) {
            case BASIC:
                nextTokenBasic();
                break;
            case EXTENDED:
                nextTokenExtended();
                break;
            default:
                throw new LexerException("Unsupported state.");
        }

        return token;
    }

    /**
     * Finds next {@code Token} for this {@code Lexer} in {@code EXTENDED} state.
     *
     * @return next {@code Token}.
     */
    private Token nextTokenExtended() {
        if (endOfLexer()) {
            return token;
        }

        // skip empty elements
        if (data[currentIndex] == ' ' || data[currentIndex] == '\t' ||
                data[currentIndex] == '\r' || data[currentIndex] == '\n') {
            currentIndex++;
            return nextTokenExtended();
        }

        if (data[currentIndex] == '#') {
            token = new Token(TokenType.SYMBOL, data[currentIndex]);
            currentIndex++;

            return token;

        }

        token = new Token(TokenType.WORD, extendedProtocol());
        return token;
    }

    /**
     * Finds next {@code Token} for this {@code Lexer} in {@code BASIC} state.
     *
     * @return next {@code Token}.
     */
    private Token nextTokenBasic() {
        if (endOfLexer()) {
            return token;
        }

        // skip empty elements
        if (data[currentIndex] == ' ' || data[currentIndex] == '\t' ||
                data[currentIndex] == '\r' || data[currentIndex] == '\n') {
            currentIndex++;
            return nextTokenBasic();
        }

        if (Character.isLetter(data[currentIndex]) || data[currentIndex] == '\\') {
            token = new Token(TokenType.WORD, letterProtocol());
            return token;
        } else if (Character.isDigit(data[currentIndex])) {
            token = new Token(TokenType.NUMBER, numericProtocol());
            return token;
        }

        // character
        token = new Token(TokenType.SYMBOL, data[currentIndex]);
        currentIndex++;

        return token;
    }

    /**
     * Used internally to check if the end of file has been reached and
     * {@link #nextToken()} has been called again.
     *
     * @return {@code true} if the end of file has been reached,
     * otherwise {@code false}.
     *
     * @throws LexerException if {@link #nextToken()} has been called
     * after the end of file has been reached.
     */
    private boolean endOfLexer() {
        if (currentIndex > data.length) {
            throw new LexerException("This lexer has given it's last token.");
        }

        if (currentIndex == data.length) {
            token = new Token(TokenType.EOF, null);
            currentIndex++;
            return true;
        }
        return false;
    }

    /**
     * Provides the current {@code Token}.
     *
     * @return current {@code Token}.
     */
    public Token getToken() {
        return token;
    }

    /**
     * Used internally to process next {@code Token} as a word.
     *
     * @return {@code String} to be used as the value of the next {@code Token}.
     *
     * @throws LexerException if escape sequence is used incorrectly.
     */
    private String letterProtocol() {
        StringBuilder ret = new StringBuilder();

        while (currentIndex < data.length && (Character.isLetter(data[currentIndex]) || data[currentIndex] == '\\')) {
            if (data[currentIndex] == '\\') {
                if (currentIndex + 1 < data.length) {
                    char current = data[currentIndex + 1];

                    if (!Character.isLetter(current)) { // if it's a number as letter skip 2 to ignore "\"
                        ret.append(current);
                        currentIndex += 2;
                        continue;
                    } else {
                        invalidEscape();
                    }
                } else {
                    invalidEscape();
                }
            }

            ret.append(data[currentIndex]);
            currentIndex++;
        }

        return ret.toString();
    }

    /**
     * Used internally to process the next {@code Token} as a number.
     *
     * @return {@code Long} to be used as the value of the next {@code Token}.
     *
     * @throws LexerException if the number cannot be parsed as {@code Long}.
     */
    private long numericProtocol() {
        StringBuilder ret = new StringBuilder();

        while (currentIndex < data.length && Character.isDigit(data[currentIndex])) {
            ret.append(data[currentIndex]);
            currentIndex++;
        }

        try {
            return Long.parseLong(ret.toString());
        } catch (NumberFormatException exc) {
            throw new LexerException("Number cannot be parsed as Long.");
        }
    }

    /**
     * Used Internally to process the next {@code Token} when
     * working in {@code EXTENDED} state.
     *
     * @return {@code String} that represents the value of the next {@code Token}.
     */
    private String extendedProtocol() {
        StringBuilder ret = new StringBuilder();

        while ((currentIndex < data.length) && (data[currentIndex] != '#' && data[currentIndex] != ' '
                && data[currentIndex] != '\t' && data[currentIndex] != '\r' && data[currentIndex] != '\n')) {
            ret.append(data[currentIndex]);
            currentIndex++;
        }

        return ret.toString();
    }

    /**
     * Used internally to throw {@code LexerException} is
     * the escape sequence is used incorrectly.
     *
     * @throws LexerException if escape sequence is used incorrectly.
     */
    private void invalidEscape() {
        throw new LexerException("Invalid use of escape sequence.");
    }

    /**
     * Used to manually change the state of a {@code Lexer}.
     *
     * @param state which we want to set.
     */
    public void setState(LexerState state) {
        if (state == null) {
            throw new NullPointerException("State cannot be null.");
        }

        this.state = state;
    }
}
